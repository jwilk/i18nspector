#!/usr/bin/python3

# Copyright © 2012 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import itertools
import os
import re
import sys

import polib

from lib import ling
from lib import tags
from lib import encodings

class Checker(object):

    def __init__(self, path, *, options):
        self.path = path
        self.options = options

    def debug(self, message, *extra):
        if self.options.debug:
            print('N:', message, *extra)

    def tag(self, tagname, *extra):
        tag = self.options.taginfo[tagname]
        s = tag.format(self.path, *extra, color=sys.stdout.isatty())
        print(s)

    def check(self):
        self.debug('path = {!r}'.format(self.path))
        extension = os.path.splitext(self.path)[-1]
        template = False
        if extension == '.po':
            constructor = polib.pofile
            self.debug('filetype = .po')
        elif extension == '.pot':
            constructor = polib.pofile
            self.debug('filetype = .po')
            template = True
        elif extension in ('.mo', '.gmo'):
            constructor = polib.mofile
            self.debug('filetype = .mo')
        else:
            self.tag('unknown-file-type')
            return
        broken_encoding = False
        try:
            file = constructor(self.path)
        except IOError as exc:
            message = str(exc)
            if message.startswith('Invalid mo '):
                self.tag('invalid-mo-file')
                return
            raise
        except UnicodeDecodeError as exc:
            file = constructor(self.path, encoding='ISO-8859-1')
            broken_encoding = exc
        if broken_encoding:
            self.tag('broken-encoding',
                repr(broken_encoding.object)[1:],
                'cannot be decoded as',
                broken_encoding.encoding.upper(),
            )
            broken_encoding = True
        if template:
            language = None
        else:
            language = self.check_language(file)
        self.check_mime(file)

    def check_language(self, file):
        language = self.options.language
        linginfo = self.options.linginfo
        language_source = 'command-line'
        if language is None:
            path_components = os.path.normpath(self.path).split('/')
            try:
                i = path_components.index('LC_MESSAGES')
            except ValueError:
                i = 0
            if i > 0:
                language = path_components[i - 1]
                language_source = 'pathname'
            del path_components
        meta_language = file.metadata.get('Language')
        self.debug('meta-language = {!r}'.format(meta_language))
        if meta_language:
            if language is None:
                language = meta_language
                language_source = 'Language header'
            elif language != meta_language:
                self.tag('language-disparity', language, '({})'.format(language_source), '!=', meta_language, '(Language header)')
        poedit_language = file.metadata.get('X-Poedit-Language')
        self.debug('poedit-language = {!r}'.format(poedit_language))
        if poedit_language:
            try:
                poedit_language = linginfo.get_language_for_name(poedit_language)
                self.debug('poedit-language = {!r}'.format(poedit_language))
            except LookupError:
                self.tag('unknown-poedit-language', poedit_language)
            else:
                if language is None:
                    language = poedit_language
                elif language != poedit_language:
                    self.tag('language-disparity', language, '({})'.format(language_source), '!=', poedit_language, '(X-Poedit-Language header)')
        if language is None:
            self.tag('unable-to-determine-language')
            return
        self.debug('language = {!r}'.format(language))
        if not meta_language:
            self.tag('no-language-header', 'Language:', language)
        return language

    def check_mime(self, file):
        mime_version = file.metadata.get('MIME-Version')
        if mime_version is not None:
            if mime_version != '1.0':
                self.tag('invalid-mime-version', mime_version, '=>', '1.0')
        else:
            self.tag('no-mime-version-header', 'MIME-Version: 1.0')
        cte = file.metadata.get('Content-Transfer-Encoding')
        if cte is not None:
            if cte != '8bit':
                self.tag('invalid-content-transfer-encoding', cte, '=>', '8bit')
        else:
            self.tag('no-content-transfer-encoding-header', 'Content-Transfer-Encoding: 8bit')
        ct = file.metadata.get('Content-Type')
        encoding = None
        if ct is not None:
            match = re.match('^text/plain; charset=([^\s;]+)$', ct)
            if match:
                encoding = match.group(1)
                try:
                    ''.encode(encoding)
                except LookupError:
                    self.tag('unknown-encoding', encoding)
                    encoding = None
                else:
                    encinfo = self.options.encinfo
                    if encinfo.is_portable_encoding(encoding):
                        pass
                    else:
                        new_encoding = encinfo.propose_portable_encoding(encoding)
                        if new_encoding is not None:
                            self.tag('non-portable-encoding', encoding, '=>', new_encoding)
                        else:
                            self.tag('non-portable-encoding', encoding)
            else:
                self.tag('invalid-content-type', ct, '=>', 'text/plain; charset=<encoding>')
        else:
            self.tag('no-content-type-header', 'Content-Type: text/plain; charset=<encoding>')
        return encoding

def require_python(*version):
    if sys.version_info < version:
        prog = argparse.ArgumentParser().prog
        print('{prog}: error: Python >= {ver} is required'.format(
            prog=prog,
            ver='.'.join(map(str, version))
        ))
        sys.exit(1)

def init_polib():
    # Do not allow broken/missing encoding declarations, unless the file is
    # ASCII-only:
    polib.default_encoding = 'ASCII'

def main():
    require_python(3, 2)
    init_polib()
    ap = argparse.ArgumentParser()
    ap.add_argument('--language', metavar='<lang>')
    ap.add_argument('--debug', action='store_true')
    ap.add_argument('files', metavar='<file>', nargs='+')
    options = ap.parse_args()
    files = options.files
    del options.files
    datadir = os.path.join(
        os.path.dirname(os.path.realpath(__file__)),
        'data', ''
    )
    os.stat(datadir)
    options.linginfo = ling.LingInfo(datadir)
    options.taginfo = tags.TagInfo(datadir)
    options.encinfo = encinfo = encodings.EncodingInfo(datadir)
    encinfo.install_extra_aliases()
    for filename in files:
        checker = Checker(filename, options=options)
        checker.check()

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
