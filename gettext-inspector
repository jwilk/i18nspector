#!/usr/bin/python3

# Copyright © 2012 Jakub Wilk <jwilk@jwilk.net>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import itertools
import os
import re
import shutil
import subprocess as ipc
import sys
import tempfile

import polib

from lib import dates
from lib import encodings
from lib import gettext
from lib import ling
from lib import tags

class Checker(object):

    def __init__(self, path, *, options):
        self.path = path
        self.fake_path = path
        if options.fake_root is not None:
            (real_root, fake_root) = options.fake_root
            if not real_root.endswith(os.sep):
                raise ValueError
            if not fake_root.endswith(os.sep):
                raise ValueError
            if path.startswith(real_root):
                self.fake_path = fake_root + path[len(real_root):]
        self.options = options

    def debug(self, message, *extra):
        if self.options.debug:
            print('N:', message, *extra)

    def tag(self, tagname, *extra):
        if tagname in self.options.ignore_tags:
            return
        tag = self.options.taginfo[tagname]
        s = tag.format(self.fake_path, *extra, color=sys.stdout.isatty())
        print(s)

    def check(self):
        self.debug('path = {!r}'.format(self.path))
        # If a file passed to polib doesn't exist, it will “helpfully” treat it
        # as PO/MO file _contents_. This is definitely not what we want. To
        # prevent such disaster, fail early if the file doesn't exit.
        try:
            os.stat(self.path)
        except EnvironmentError as exc:
            self.tag('os-error', tags.safestr(exc.strerror))
            return
        extension = os.path.splitext(self.path)[-1]
        template = False
        if extension == '.po':
            constructor = polib.pofile
            self.debug('filetype = .po')
        elif extension == '.pot':
            constructor = polib.pofile
            self.debug('filetype = .po')
            template = True
        elif extension in ('.mo', '.gmo'):
            constructor = polib.mofile
            self.debug('filetype = .mo')
        else:
            self.tag('unknown-file-type')
            return
        broken_encoding = False
        try:
            try:
                file = constructor(self.path)
            except UnicodeDecodeError as exc:
                broken_encoding = exc
                file = constructor(self.path, encoding='ISO-8859-1')
                # FIXME: Because of http://bugs.debian.org/692283, using
                # ISO-8859-1 can trigger spurious syntax errors. A custom
                # encoding that can never produce U+0085 NEXT LINE would be
                # more robust.
        except IOError as exc:
            message = str(exc)
            if exc.errno is not None:
                self.tag('os-error', tags.safestr(exc.strerror))
                return
            elif message.startswith('Invalid mo '):
                self.tag('invalid-mo-file')
                return
            elif message.startswith('Syntax error in po file '):
                message = message[24:]
                message_parts = []
                if message.startswith(self.path + ' '):
                    message = message[len(self.path)+1:]
                match = re.match(r'^\(line ([0-9]+)\)(?:: (.+))?$', message)
                if match is not None:
                    lineno_part = 'line {}'.format(match.group(1))
                    message = match.group(2)
                    if message is not None:
                        lineno_part += ':'
                        if re.match(r'^[a-z]+( [a-z]+)*$', message):
                            message = tags.safestr(message)
                    message_parts += [tags.safestr(lineno_part)]
                if message is not None:
                    message_parts += [message]
                self.tag('syntax-error-in-po-file', *message_parts)
                return
            raise
        finally:
            if broken_encoding:
                self.tag('broken-encoding',
                    tags.safestr(repr(broken_encoding.object)[1:]),
                    tags.safestr('cannot be decoded as'),
                    broken_encoding.encoding.upper(),
                )
                broken_encoding = True
        if template:
            language = None
        else:
            language = self.check_language(file)
        self.check_mime(file)
        self.check_dates(file)
        self.check_headers(file)

    def check_language(self, file):
        language = self.options.language
        linginfo = self.options.linginfo
        language_source = 'command-line'
        if language is None:
            path_components = os.path.normpath(self.path).split('/')
            try:
                i = path_components.index('LC_MESSAGES')
            except ValueError:
                i = 0
            if i > 0:
                language = path_components[i - 1]
                language_source = 'pathname'
            del path_components
        meta_language = file.metadata.get('Language')
        self.debug('meta-language = {!r}'.format(meta_language))
        if meta_language:
            if language is None:
                language = meta_language
                language_source = 'Language header field'
            elif language != meta_language:
                self.tag('language-disparity',
                    language, tags.safestr('({})'.format(language_source)),
                    '!=',
                    meta_language, tags.safestr('(Language header field)')
                )
        poedit_language = file.metadata.get('X-Poedit-Language')
        self.debug('poedit-language = {!r}'.format(poedit_language))
        if poedit_language:
            # FIXME: This should take also X-Poedit-Country into account.
            try:
                poedit_language = linginfo.get_language_for_name(poedit_language)
                self.debug('poedit-language = {!r}'.format(poedit_language))
            except LookupError:
                self.tag('unknown-poedit-language', poedit_language)
            else:
                if language is None:
                    language = poedit_language
                elif language != poedit_language:
                    self.tag('language-disparity',
                        language, tags.safestr('({})'.format(language_source)),
                        '!=',
                        poedit_language, tags.safestr('(X-Poedit-Language header field)')
                    )
        if language is None:
            self.tag('no-language-header-field')
            assert not meta_language
            self.tag('unable-to-determine-language')
            return
        self.debug('language = {!r}'.format(language))
        if not meta_language:
            self.tag('no-language-header-field', tags.safestr('Language:'), language)
        return language

    def check_mime(self, file):
        mime_version = file.metadata.get('MIME-Version')
        if mime_version is not None:
            if mime_version != '1.0':
                self.tag('invalid-mime-version', mime_version, '=>', '1.0')
        else:
            self.tag('no-mime-version-header-field', tags.safestr('MIME-Version: 1.0'))
        cte = file.metadata.get('Content-Transfer-Encoding')
        if cte is not None:
            if cte != '8bit':
                self.tag('invalid-content-transfer-encoding', cte, '=>', '8bit')
        else:
            self.tag('no-content-transfer-encoding-header-field', tags.safestr('Content-Transfer-Encoding: 8bit'))
        ct = file.metadata.get('Content-Type')
        encoding = None
        if ct is not None:
            match = re.match('^text/plain; charset=([^\s;]+)$', ct)
            if match:
                encoding = match.group(1)
                try:
                    ''.encode(encoding)
                except LookupError:
                    self.tag('unknown-encoding', encoding)
                    encoding = None
                else:
                    encinfo = self.options.encinfo
                    if encinfo.is_portable_encoding(encoding):
                        pass
                    else:
                        new_encoding = encinfo.propose_portable_encoding(encoding)
                        if new_encoding is not None:
                            self.tag('non-portable-encoding', encoding, '=>', new_encoding)
                        else:
                            self.tag('non-portable-encoding', encoding)
            else:
                self.tag('invalid-content-type', ct, '=>', 'text/plain; charset=<encoding>')
        else:
            self.tag('no-content-type-header-field', tags.safestr('Content-Type: text/plain; charset=<encoding>'))
        return encoding

    def check_dates(self, file):
        for field in 'POT-Creation-Date', 'PO-Revision-Date':
            date = file.metadata.get(field)
            if date is None:
                self.tag('no-date-header-field', field)
                continue
            fixed_date = dates.fix_date_format(date)
            if fixed_date is None:
                self.tag('invalid-date', tags.safestr(field + ':'), date)
                continue
            elif date != fixed_date:
                self.tag('invalid-date', tags.safestr(field + ':'), date, '=>', fixed_date)
            stamp = dates.parse_date(fixed_date)
            if stamp > dates.now:
                self.tag('date-from-future', tags.safestr(field + ':'), date)
            if stamp < dates.gettext_epoch:
                self.tag('ancient-date', tags.safestr(field + ':'), date)

    def check_headers(self, file):
        for key in sorted(file.metadata):
            if key.startswith('X-'):
                continue
            if key not in self.options.gettextinfo.po_header_fields:
                self.tag('unknown-header-field', key)

def require_python(*version):
    if sys.version_info < version:
        prog = argparse.ArgumentParser().prog
        print('{prog}: error: Python >= {ver} is required'.format(
            prog=prog,
            ver='.'.join(map(str, version))
        ))
        sys.exit(1)

def init_polib():
    # Do not allow broken/missing encoding declarations, unless the file is
    # ASCII-only:
    polib.default_encoding = 'ASCII'

def check_file(filename, *, options):
    checker = Checker(filename, options=options)
    checker.check()

def copy_options(options, **update):
    kwargs = vars(options)
    kwargs.update(update)
    return argparse.Namespace(**kwargs)

class UnsupportedFileType(ValueError):
    pass

def check_deb(filename, *, options):
    if filename.endswith('.deb'):
        binary = True
    elif filename.endswith('.dsc'):
        binary = False
    else:
        raise UnsupportedFileType
    tmpdir = tempfile.mkdtemp()
    ignore_tags = set(options.ignore_tags)
    ignore_tags.add('unknown-file-type')
    try:
        if binary:
            ipc.check_call(['dpkg-deb', '-x', filename, tmpdir])
            control_dir = os.path.join(tmpdir, 'DEBIAN')
            os.mkdir(control_dir)
            ipc.check_call(['dpkg-deb', '-e', filename, control_dir])
            real_root = os.path.join(tmpdir, '')
        else:
            real_root = os.path.join(tmpdir, 's', '')
            with open(os.devnull) as bitbucket:
                ipc.check_call(
                    ['dpkg-source', '--no-copy', '--no-check', '-x', filename, real_root],
                    stdout=bitbucket # dpkg-source would be noisy without this...
                )
        options = copy_options(options,
            ignore_tags=ignore_tags,
            fake_root=(real_root, os.path.join(filename, ''))
        )
        for root, dirs, files in os.walk(tmpdir):
            for path in files:
                path = os.path.join(root, path)
                if os.path.islink(path):
                    continue
                if os.path.isfile(path):
                    check_file(path, options=options)
    finally:
        shutil.rmtree(tmpdir)

def main():
    require_python(3, 2)
    init_polib()
    is_debian = os.path.exists('/etc/debian_version')
    ap = argparse.ArgumentParser()
    ap.add_argument('-l', '--language', metavar='<lang>')
    ap.add_argument('--debian', action='store_true', default=is_debian)
    ap.add_argument('--debug', action='store_true')
    ap.add_argument('files', metavar='<file>', nargs='+')
    options = ap.parse_args()
    files = options.files
    del options.files
    datadir = os.path.join(
        os.path.dirname(os.path.realpath(__file__)),
        'data', ''
    )
    os.stat(datadir)
    options.encinfo = encinfo = encodings.EncodingInfo(datadir)
    options.gettextinfo = gettext.GettextInfo(datadir)
    options.linginfo = linginfo = ling.LingInfo(datadir)
    options.taginfo = tags.TagInfo(datadir)
    encinfo.install_extra_aliases()
    if options.language is not None:
        try:
            language = linginfo.parse_language(options.language)
            language.fix_codes()
        except ling.LanguageError:
            if options.debug:
                raise
            ap.error('invalid language')
        language.remove_encoding()
        language.remove_nonlinguistic_modifier()
        options.language = str(language)
    options.ignore_tags = set()
    options.fake_root = None
    for filename in files:
        if options.debian:
            try:
                check_deb(filename, options=options)
            except UnsupportedFileType:
                pass
            else:
                continue
        check_file(filename, options=options)

if __name__ == '__main__':
    main()

# vim:ts=4 sw=4 et
